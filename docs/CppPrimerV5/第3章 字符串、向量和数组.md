# 第 3 章 字符串向量和数组

## 3.3 标准库类型 vector

标准库类型 vector 表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为 vector“容纳着”其他对象，所以他也经常被称为容器。

想要使用 vector，必须包含头文件`vector`

vector 是一个类模板，模板本身不是类或函数。编译器根据模板创建类（实例化），对于类模板我们提供一些额外的信息来指定需要实例化成什么样的类。以 vector 为例，提供的额外信息是 vector 内所存放的对象的类型：

```C++
vector<int> ivec;               // ivec保存int类型的对象
vector<Sales_item> Sales_vec;   // 保存Sales_item类型的对象
vector<vector<string>> file;    // 该向量的元素是vector对象
```

### 3.3.1 定义和初始化对象

和任何一种类型一样，vector 模板控制着定义和初始化向量的方法。

|                            |                                          |
| -------------------------- | ---------------------------------------- |
| vector\<T\> v1             | v1 是一个空的 vector                     |
| vector\<T\> v2(v1)         | v2 包含 v1 所有的元素                    |
| vector\<T\> v2 = v1        | 同上                                     |
| vector\<T\> v3(n, val)     | v3 包含 n 个重复的元素，每个元素都是 val |
| vector\<T\> v4(n)          | v4 包含 n 个重复地执行了值初始化的对象   |
| vector\<T\> v5\{a,b,c,d\}  | v5 包含初始值个数的元素\{a,b,c,d\}       |
| vector\<T\> v5=\{a,b,c,d\} | 同上                                     |

#### 圆括号和花括号

在某些情况下，初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号。 如 v3,v4 和 v5：

```C++
vector<int> v1(10);     // {0,0,0,0,0,0,0,0,0,0}
vector<int> v1{10};     // {10}
vector<int> v1(10, 5);  // {5,5,5,5,5,5,5,5,5,5}
vector<int> v1{10, 5};  // {10, 5}
```

### 3.3.2 向 vector 对象添加元素

使用 push_back 添加对象

```C++
vector<int> intVec;
for(int i=0;i<=100;i++)
    intVec.push_back(i);

// intVec 是 {0，1，2，3..100}

intVec.push_back(-1);

// intVec 是 {0，1，2，3..100，-1}
```

push_back 负责将一个值添加到 vector 对象的末尾。

同样的，如果需要输入多个单词到 vector

```C++
std::string word;
vector<std::string> text;
while(std::cin >> word)
{
    text.push_back(word);
}
```

#### 向 vector 对象添加元素的要求

1. 在改变 vector 对象容量时，必须保证循环无误。

2. 如果循环体内包含有像 vector 对象添加元素的语句，则不能使用 for 循环，for 语句不应改变其所遍历的序列大小。

### 3.3.3 其他 vector 操作

|                |                                          |
| -------------- | ---------------------------------------- |
| v.empty()      | 判断 vector 是否为空                     |
| v.size()       | 元素个数                                 |
| v.push_back(t) | 在末尾添加 t 对象                        |
| v\[n\]         | 第 n 个位置的元素，其实位置是 0          |
| v1 = v2        | 用这 v2 中的元素替换 v1 中的元素         |
| v1 = \{a,b,c\} | 用列表中的元素替换 v1 中的元素           |
| v1 == v2       | 判断 v1 和 v2 的元素数量和值是否完全相同 |
| v1 != v2       | 上面的取反                               |
| <,<=,>,>=      | 以字典的顺序进行比较                     |

#### 下标

不能用下标的形式添加元素，而且只能对明确存在的元素执行下标操作。

## 3.4 迭代器

迭代器提供了对对象的间接访问。对象是容器中的元素或 string 对象中的字符。

迭代器可以访问某个元素，也可以从一个元素移动到另外一个元素。迭代器有有效和无效之分。

### 3.4.1 使用迭代器

容器都拥有 begin 和 end 的成员函数，begin()指向第一个元素，end()指向最后一个元素后面的一个不存在的元素,如果容器为空，则 begin()和 end()是同一个迭代器。

#### 迭代器运算符

|                |                                                               |
| -------------- | ------------------------------------------------------------- |
| \*iter         | 返回迭代器                                                    |
| iter->mem      | 解引用 iter 并获取该元素的名为 mem 的成员，等价于(\*iter).mem |
| ++iter         | 令 iter 指示容器中的下一个元素                                |
| --iter         | 令 iter 指示容器中的上一个元素                                |
| iter1 == iter2 | 判断是否指向同一个元素                                        |

凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。

