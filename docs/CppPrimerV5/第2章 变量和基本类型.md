# 第 2 章 变量和基本类型

数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作。

C++语言支持广泛的数据类型。它定义了几种基本的数据类型（如字符、整数、浮点数、），同时也为程序员提供了自定义数据类型的机制。基于此，C++标准库定义了一些更加复杂的数据类型，比如可变长字符串和向量等。

数据类型决定了程序中数据和操作的意义。

```c++
i = i + j;
```

其含义依赖于 i 和 j 的数据类型。如果 i 和 j 都是整数，那么这条语句执行的就是最普通的加法运算。然而，如果 i 和 j 是 Sales_item 类型的数据，则是把这两个对象的成分相加。

## 2.1 基本内置类型

C++定义了一套包括**算术类型**（arithmetic type）和**空类型**（void）在内的基本数据类型。其中算术类型包含了字符、整数、布尔和浮点数。空类型不对应具体的值，仅用于一些特殊场合，例如常见的是，当函数不返回任何值时使用空类型作为返回。

### 2.1.1 算术类型

算术类型分为两类：**整型**（integral type， 包括字符和布尔类型在内）和浮点型。

算术类型的大小在不同机器上时不同的，允许编译器赋予这些类型更大的大小

|    类型     |      含义      |   最小大小    |
| :---------: | :------------: | :-----------: |
|    bool     |    布尔类型    |    未定义     |
|    char     |      字符      |     8bit      |
|   wchar_t   |     宽字符     |     16bit     |
|  char16_t   |  Unicode 字符  |     16bit     |
|  char32_t   |  Unicode 字符  |     32bit     |
|    short    |     短整型     |     16bit     |
|     int     |      整型      |     16bit     |
|    long     |     长整型     |     32bit     |
|  long long  |     长整型     |     64bit     |
|    float    |  单精度浮点数  | 6 位有效数字  |
|   double    |  双精度浮点数  | 10 位有效数字 |
| long double | 扩展精度浮点数 | 10 为有效数字 |

布尔类型（bool）的取值是真（true）或假（false）

C++提供了几种字符类型，其中多数支持国际化。基本的字符类型是一个 char，一个 char 的空间确保可以存放机器基本字符集中的任意字符对应的数字值。也就是说，一个 char 的大小和一个机器字节一样。

其他字符类型用于扩展字符集，如 wchar_t、char16_t、char32_t、wchar_t 类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型 char16_t 和 char32_t 则为 Unicode 字符集服务。

除字符和布尔类型之外，其他整型用于表示（可能）不同大小的整数。c++语言规定一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。

:::warning 内置类型的机器实现
计算机以 bit 序列存储数据，每个 bit 非 0 即 1，例如：

`00011011011100010110010000111011....`

大多数计算机以 2 的整数次幂个作为块来处理内存，可寻址的最小内存块为`字节（byte）`，存储的基本单元称为`字（word）`,它通常有几个字节组成，在 c++语言中，一个字节至少能容纳机器基本字符集中的字符。大多数机器的字节有 8bit 构成，字则有 32 或 64bit 构成，也就是 4 或 8 字节。

大多数计算机将内存的每个字节与一个数字（被称为“地址（address）”）关联起来，在一个字节为 8bit、字为 32bit 的机器上我们可能看到的一个字的内存区域如下所示：

`=> 0x00073546 [0,0,1,1,1,0,1,1]`

`   0x00073547 [0,0,0,1,1,0,1,1]`

`   0x00073548 [0,1,1,1,0,0,0,1]`

`   0x00073549 [0,1,1,0,0,1,0,0]`

其中，左侧是字节的地址，右侧是字节中 8bit 的具体内容。

我们使用某个地址来表示从这个地址开始的大小不同的二进制串，例如我们可能会说地址 73546 的那个字或地址 73549 那个字节。为了赋予内存某个地址明确的含义，必须首先知道存储在该地址的数据类型。类决定了该如何解读该二进制串。
:::

浮点型可表示单精度、双精度和扩展精度值。C++标准指定了一个浮点数的有效位数的最小值。然而大多数编译器都实现了更高精度。通常，float 以 1 个字（32bit）来表示，double 以 2 个字（64bit）来表示，long double 以 3 或 4 个字（96 或 128bit）来表示。一般来说，类型 float 和 double 分别有 7 和 16 个有效位；类型 long double 则常常被用于特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。

#### 带符号类型和无符号类型

除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的（signed）和无符号的（unsigned）两种。带符号类型可以表示整数、负数或 0，无符号类型则仅能表示大于等于 0 的值。

类型 int、short、long 和 long long 都是带符号的，通过在这些类型名前添加 unsigned 就可以得到无符号类型，例如 unsigned long。 unsigned int 可以缩写为 unsigned。

与其他类型不同，字符型被分为三种：char、signed char 和 unsigned char。 特别需要注意的是：类型 char 和类型 signed char 并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型 char 实际上会表现为上述两种形式中的一种，具体是那种由编译器决定。

无符号类型中所有比特都用来存储值，例如，8bit 的 unsigned char 可以表示 0 至 255 区间内的值。

C++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内的正值和负值的量应该平衡。因此，8bit 的 signed char 理论上应该是-127 至 127 区间内的值，大多数现代计算机将实际的表示范围定位-128 至 127。

:::tip 建议：如何选择类型
和 C 语言一样，C++和设计准则之一也是尽可能地接近硬件。C++的算术类型必须满足各种硬件特质，所以它们常常显得复杂而令人不知所措。事实上，大多数程序员能够（也应该）对数据类型的使用做出限定从而简化选择的过程。以下是选着类型的一些经验准则：

- 当明确知道数值不可能为负数时，选用无符号整型。
- 使用 int 执行整数运算。在实际应用中，short 常常显得太小而 long 一般和 int 有一样的大小。如果你的数值超过了 int 的表示范围，选用 long long。

在算术表达式中不要使用 char 或 bool，只有在存放字符或布尔值时才使用它们。因为类型 char 在一些机器上时有符号的，而在另一些机器上又是无符号的，所以如果使用 char 进行运算特别容易出现问题。如果你需要使用一个不大的整数，那么明确指定它的类型是 signed char 或者 unsigned char。

执行浮点数运算选用 double，这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数的计算相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。long double 提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容易忽视。
:::

:::details 练习 2.1
类型 int、long、long long 和 short 的区别是什么？无符号类型和带符号类型的区别是什么？float 和 double 的区别是什么？
:::

:::detaile 练习 2.2
计算按揭贷款时，对于利率本金和付款分别应该选择何种数据类型？说明你的理由。
:::

### 2.1.2 类型转换

对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型转换（convert）为另一种相关类型。

当在程序的某处我们使用了一种数据类型而其实对象应该取另一种类型时，程序会自动进行类型转换。有必要说明某种类型的对象强行赋了另一种值时，到底会发生什么。

当我们像下面这样把一种算术类型的值赋给另外一种类型时；

```C++
bool b = 42; // b为真
int i = b; // i=1
i=3.14      // i=3
double pi = i // pi = 3.0
unsigned char c = -1; //  假设char占8bit，c的值为255
singned char c2 = 256 // 假设char占8bit，c2的值是未定义的
```

类型所能表示的值的范围决定了转换的过程：

- 当我们把一个非布尔类型的算术赋值给布尔类型时，初始值为 0 则结果为 false，否则为 true。
- 当我们把一个布尔值赋给非布尔类型是，初始值为 false 则结果为 0，初始值为 true 则结果为 1.
- 当我们把一个浮点数赋值给整数类型时，进行近似处理。结果值将仅保留浮点数中小数点之前的部分。
- 当我们把一个整数赋值给浮点数时，小数部分标记为 0。如果该整数所占空间超过浮点类型的容量，精度可能有损失。
- 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8bit 大小的 unsigned char 可以表示 0 至 255 区间内的值，如果我们赋了一个区间外的值，则实际的结果是该值对 256 取模后得到的余数。因此，把-1 赋给 8bit 大小的 unsigned char 所得的结果是 255。
- 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃、也可能生成垃圾数据。

:::tip 建议：避免无法预知和依赖于实现环境的行为
无法预知的行为源于编译器无须（有时是不能）检测错误。即使代码编译通过了，如果程序执行了一条未定义的表达式，仍有可能产生错误。

不幸的是，在某些情况下和/或某些情况下，含有无法预知行为的程序也能正确执行。但我们无法保证同样一个程序在别的编译器下能正常工作，升值已经编译通过的代码再次执行也可能会出错。此外，也不能认为这样的程序对一组输入有效，对另一组输入就一定有效。

程序也应尽量不免依赖于实现环境。如果无门把 int 的大小看成是一个确定不变的已知值，那么这样的程序就称作不可移植的（nonportable），当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误可不是一件轻松愉快的工作。

:::

当在程序的某处使用了一种算术类型的值而其实所需的是另外一种类型的值时，编译器同样会执行生疏的类型转换。例如，如果我们使用了一个非布尔值作为条件，那么它会被自动的转换为布尔值，这一做法和把非布尔值赋值给布尔变量时的错做完全一样：

```C++
    int i = 42;
    if(i)
        i = 0;
```

如果 i 的值为 0，则田间的值为 false；i 的所有其他值都将使条件为 true。

以此类推，如果我们把一个布尔值用在算术表达式里，则它的取值非 0 即 1，所以一般不宜在算术表达式里使用布尔值。

#### 含有无符号类型的表达式

尽管我们不会故意给无符号对象赋一个负值，却可能（特别容易）写出这么做的代码。例如，当一个算术表达式中既有无符号数又有 yint 值时，那个 int 值就会转换成无符号数。把 int 转换成无符号数的过程和把 int 直接赋给无符号变量一样：

```c++
    unsigned u = 10;
    int i = -42;
    std::cout << i+i <<std::endl; // 输出-84
    std::cout << u + i << std::endl; // 如果int占32位，输出4294967264
```

在第一个输出表达式里，两个（负）整数相加并得到了预期的结果。在第二个输出表达式里，相加前先把整数-42 转换成无符号数。把负数转换成无符号数类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模。

当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果是一个负值：

```c++
    unsigned u1 = 42, u2 = 10;
    std::cout << u1 - u2 << std::endl; // 正确：输出32
    std::cout << u2 - u1 << std::endl; // 正确：不过，结果是取模后的值
```

:::warning unsigned & signed
以 一个 8 位的数字为例，
有符号数的最高位的表示符号
0000 0001 代表1 相反数“取反+1” 为1111 1111 = -1。
无符号的0000 0001 同样代表1 而 1111 1111 代表255。
上面的例子 10 - 42 = -32 可以通过一系列的运算推出二进制的表示方法，
32的二进制表示是0010 0000，所以-32的二进制表示为1101 1111 + 1 = 1110 0000 的无符号十进制表示为22，而 -32 取模 256 刚好是 224。
:::

无符号数不会小于0这一事实同样关系到循环的写法。例如在[练习1](./第1章%20开始)中需要写一个循环，通过控制变量递减的方式把从10到0的数字降序输出。这个循环可能类似于下面的形式：
```c++
for(int i= 10 ; i >= 0; --i)
    std::cout << i << std::endl;
```

